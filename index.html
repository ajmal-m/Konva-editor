<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Konva Canvas Editor â€” Drag, Resize, Export</title>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');
  </style>
  <style>
    :root { --bg:#0b1020; --panel:#0e162b; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 800px at 10% 10%, #0f172a, #0b1020 70%, #070b17 100%);color:#e5e7eb;font-family:system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial}
    .app{display:grid;grid-template-rows:auto 1fr;min-height:100vh}
    .toolbar{display:flex;height: 50px;gap:10px;align-items:center;justify-content:space-between;padding:10px 12px;background:rgba(10,16,32,.7);border-bottom:1px solid #1f2937;backdrop-filter:blur(6px)}
    .group{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .label{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
    .btn,.input,.select{background:#0b1220;color:#e5e7eb;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;font-weight:600;cursor:pointer}
    .btn:hover,.input:hover,.select:hover{border-color:#334155}
    .btn:active{transform:translateY(1px)}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .input[type="color"]{padding:0;width:40px;height:36px}
    #stage-wrap{position:relative;height:calc(100vh - 70px)}
    #container{width:100%;height:100%}
    .hint{position:absolute;right:10px;bottom:10px;font-size:12px;color:#93c5fd;background:rgba(2,6,23,.6);padding:6px 10px;border-radius:10px;border:1px solid #172554}
  </style>
  <link rel="stylesheet" href="index.css">
  <link rel="stylesheet" href="font.css">
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <div class="group">
        <button class="tool-btn"  id="add-rect" title="Rectangle" data-tool="rect">
          <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="12"/></svg>
        </button>
        <button class="tool-btn" id="add-circle" title="Circle" data-tool="circle">
          <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg>
        </button>
        <button class="tool-btn" title="Star" data-tool="star"  id="add-star">
          <svg viewBox="0 0 24 24">
            <polygon points="12,3 15,10 22,10 17,14 19,21 12,17 5,21 7,14 2,10 9,10"/>
          </svg>
        </button>
        <button class="tool-btn" title="Arrow" data-tool="arrow" id="add-arrow">
          <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="15,8 19,12 15,16"/></svg>
        </button>
        <button class="tool-btn" title="Text" data-tool="text" id="add-text">
          <svg viewBox="0 0 24 24"><path d="M4 6h16M12 6v12"/></svg>
        </button>
      </div>
      <!-- <div class="group">
        <span class="label">Style</span>
        <span class="label">Fill</span><input class="input" type="color" id="fill" value="#22d3ee" />
        <span class="label">Stroke</span><input class="input" type="color" id="stroke" value="#ffffff" />
        <span class="label">Width</span><input class="input" type="number" id="strokeWidth" min="0" max="20" value="2" style="width:72px" />
        <span class="label">Radius</span><input class="input" type="number" id="cornerRadius" min="0" max="20" value="2" style="width:72px" />
        <span class="label">Blur</span><input class="input" type="range" id="blurRadius" min="0" max="40" value="0" style="width:72px" />
        <span class="label">Image Upload</span><input class="input" type="file" id="imageUpload" accept="image/*" />
        <label class="label" style="display:flex;gap:6px;align-items:center"><input id="snap" type="checkbox" /> Snap</label>
        <label class="label" style="display:flex;gap:6px;align-items:center"><input id="grid" type="checkbox" checked/> Grid</label>
      </div>
      <div class="group">
        <button class="btn" id="bring-front">Bring Front</button>
        <button class="btn" id="send-back">Send Back</button>
        <button class="btn" id="duplicate">Duplicate</button>
        <button class="btn" id="remove">Delete</button>
        <button class="btn" id="export">Export PNG</button>
        <button class="btn" id="clear">Clear</button>
      </div> -->
    </div>

    <div id="stage-wrap">
      <div id="container"></div>
      <!-- <div id="properties-drawer" > -->

        <!-- <h2 class="poppins-medium text-12">
          Properties
        </h2> -->

        <!-- Transform Section -->
        <!-- <div style="margin-bottom: 16px;">
          <h3  class="text-14 poppins-medium prop-heading">Transform</h3>
          <label class="prop-label">X <input type="number" id="prop-x" class="prop-input"></label>
          <label class="prop-label">Y <input type="number" id="prop-y" class="prop-input"></label>
          <label class="prop-label">Width <input type="number" id="prop-width" class="prop-input"></label>
          <label class="prop-label">Height <input type="number" id="prop-height" class="prop-input"></label>
          <label class="prop-label">Rotation <input type="number" id="prop-rotation" class="prop-input"></label>
          <label class="prop-label">SkewX <input type="number" id="prop-skewx" class="prop-input"></label>
          <label class="prop-label">SkewY <input type="number" id="prop-skewy" class="prop-input"></label>
        </div> -->

        <!-- Style Section -->
        <!-- <div style="margin-bottom: 16px;">
          <h3 class="text-14 poppins-medium prop-heading">Style</h3>
          <label class="prop-label">Fill <input type="color" id="prop-fill" class="prop-input"></label>
          <label class="prop-label">Stroke <input type="color" id="prop-stroke" class="prop-input"></label>
          <label class="prop-label">Stroke Width <input type="number" id="prop-stroke-width" class="prop-input"></label>
          <label class="prop-label">Opacity <input type="range" min="0" max="1" step="0.05" id="prop-opacity" class="prop-input"></label>
        </div> -->

        <!-- Text Section (only for text nodes) -->
        <!-- <div id="text-section" style="margin-bottom:16px;">
          <h3 class="text-14 poppins-medium prop-heading">Text</h3>
          <label class="prop-label">Font Size <input type="number" id="prop-fontsize" class="prop-input"></label>
        </div> -->

      <!-- </div> -->
    </div>
    <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="context-menu-copy-item">
      <!-- Copy Icon -->
      <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v16c0 
      1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 18H8V7h11v16z"/></svg>
      Copy
    </div>
    <div class="context-menu-item" id="context-menu-paste-item">
      <!-- Paste Icon -->
      <svg viewBox="0 0 24 24"><path d="M19 2h-4.18C14.4.84 13.3 0 12 
      0s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 
      1.1.9 2 2 2h14c1.1 0 2-.9 
      2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 
      1 .45 1 1s-.45 1-1 1-1-.45-1-1 
      .45-1 1-1zm7 18H5V4h2v2h10V4h2v16z"/></svg>
      Paste
    </div>
    <div class="context-menu-item" id="context-menu-delete-item">
      <!-- Delete Icon -->
      <svg viewBox="0 0 24 24"><path d="M16 9v10H8V9h8m-1.5-6h-5l-1 
      1H5v2h14V4h-4.5l-1-1z"/></svg>
      Delete
    </div>
  </div>
  </div>


  <script>
    // --- Stage & layers ---
    const stage = new Konva.Stage({ container: 'container', width: window.innerWidth, height: window.innerHeight - 70 });
    const gridLayer = new Konva.Layer();
    const layer = new Konva.Layer();
    let currentNode = null;
    let isEditingText = false;
    let copiedNode = null;
    let contextMenuLocation = { x: 0, y: 0 };

    const DEFAULT_PROPERTIES={
      'transform':{
        x: 0, y: 0, width: 100, height: 100, rotation: 0, skewX: 0, skewY: 0, scaleX: 1, scaleY: 1, strokeWidth: 0
      },
      'style':{
        fill: 'red', stroke: 'black', strokeWidth: 0, opacity: 1
      },
      'text':{
        fontSize: 20
      }
    }

    stage.add(gridLayer);
    stage.add(layer);

    // --- Grid drawing ---
    const GRID_SIZE = 20;
    function drawGrid() {
      gridLayer.destroyChildren();
      const w = stage.width();
      const h = stage.height();
      for (let x = 0; x < w; x += GRID_SIZE) {
        gridLayer.add(new Konva.Line({ points: [x,0,x,h], stroke: 'rgba(148,163,184,0.15)', strokeWidth: 1 }));
      }
      for (let y = 0; y < h; y += GRID_SIZE) {
        gridLayer.add(new Konva.Line({ points: [0,y,w,y], stroke: 'rgba(148,163,184,0.15)', strokeWidth: 1 }));
      }
      gridLayer.cache();
      gridLayer.draw();
    }
    drawGrid();

    // --- Transformer ---
    const tr = new Konva.Transformer({ rotateEnabled: true, enabledAnchors: ['top-left','top-right','bottom-left','bottom-right','middle-left','middle-right','top-center','bottom-center'] });
    layer.add(tr);

    function selectNode(node) {
      if (currentNode &&  currentNode?.type in toolbarIcons) toolbarIcons[currentNode.type].classList.remove('active');
      removePropertyPanel();
      if (!node) { tr.nodes([]); layer.draw(); return; }
      if(node.type && node.type in toolbarIcons){
        toolbarIcons[node.type].classList.add('active');
      }
      tr.nodes([node]);
      tr.moveToTop();
      layer.draw();
      createPropertyPanel(node.attrs);
      // syncUIFromNode(node);
      currentNode = node;
    }

    // --- Helpers ---
    const ui = {
      fill: document.getElementById('fill'),
      stroke: document.getElementById('stroke'),
      strokeWidth: document.getElementById('strokeWidth'),
      cornerRadius: document.getElementById('cornerRadius'),
      snap: document.getElementById('snap'),
      grid: document.getElementById('grid'),
      imageUpload: document.getElementById('imageUpload'),
      blurRadius: document.getElementById('blurRadius'),
      contextMenu: document.getElementById('contextMenu')
    };


    // Toolbar Icons
    const toolbarIcons = {
      rect: document.getElementById("add-rect"),
      circle: document.getElementById("add-circle"),
      star: document.getElementById("add-star"),
      arrow: document.getElementById("add-arrow"),
      text: document.getElementById("add-text")
    };

    // Update node style 
    function updateNodeStyle(node, label, value) {
      const setters = {
        x: v => node.x(parseFloat(v) || 0),
        y: v => node.y(parseFloat(v) || 0),
        width: v => node.width(parseFloat(v) || 0),
        height: v => node.height(parseFloat(v) || 0),
        fill: v => node.fill(v),
        stroke: v => node.stroke(v),
        strokeWidth: v => node.strokeWidth(parseFloat(v) || 0),
        cornerRadius: v => node.cornerRadius(parseFloat(v) || 0),
        opacity: v => node.opacity(parseFloat(v) || 1),
        shadowColor: v => node.shadowColor(v),
        shadowBlur: v => node.shadowBlur(parseFloat(v) || 0),
        shadowOffsetX: v => node.shadowOffsetX(parseFloat(v) || 0),
        shadowOffsetY: v => node.shadowOffsetY(parseFloat(v) || 0),
        shadowOpacity: v => node.shadowOpacity(parseFloat(v) || 1),
        text: v => node.text(v),
        fontSize: v => node.fontSize(parseInt(v) || 16),
        fontFamily: v => node.fontFamily(v),
        fontStyle: v => node.fontStyle(v),
        align: v => node.align(v),
        lineHeight: v => node.lineHeight(parseFloat(v) || 1),
        letterSpacing: v => node.letterSpacing(parseFloat(v) || 0),
        rotation: v => node.rotation(parseFloat(v) || 0),
        scaleX: v => node.scaleX(parseFloat(v) || 1),
        scaleY: v => node.scaleY(parseFloat(v) || 1),
        skewX: v => node.skewX(parseFloat(v) || 0),
        skewY: v => node.skewY(parseFloat(v) || 0),
      };

      if( label in setters ){
        setters[label](value);
      }

      node.getLayer().batchDraw();
    }



    function applyStyle(node){
      if (!node) return;
      if ('fill' in node.attrs) node.fill(ui.fill.value);
      if ('stroke' in node.attrs) node.stroke(ui.stroke.value);
      if ('strokeWidth' in node.attrs) node.strokeWidth(parseFloat(ui.strokeWidth.value)||0);
      if ('cornerRadius' in node.attrs) node.cornerRadius(parseFloat(ui.cornerRadius.value)||0);
      layer.batchDraw();
    }

    function syncUIFromNode(node){
      if (!node) return;
      if ('fill' in node.attrs && typeof node.fill() === 'string') ui.fill.value = toHex(node.fill());
      if ('stroke' in node.attrs && typeof node.stroke() === 'string') ui.stroke.value = toHex(node.stroke());
      if ('strokeWidth' in node.attrs) ui.strokeWidth.value = node.strokeWidth() || 0;
    }

    function toHex(color){
      const ctx = document.createElement('canvas').getContext('2d');
      ctx.fillStyle = color; // browser normalizes
      const computed = ctx.fillStyle; // rgb(a) or hex
      if (computed.startsWith('#')) return computed;
      const m = computed.match(/\d+/g).map(Number);
      return '#' + m.slice(0,3).map(n => n.toString(16).padStart(2,'0')).join('');
    }

    function commonShapeProps(){
      return { fill: ui.fill?.value || 'red', stroke: ui.stroke?.value || 'black', strokeWidth: parseFloat(ui.strokeWidth?.value)||0, draggable: true, name: 'shape' };
    }

    function attachNodeEvents(node){
      node.on('click', (e)=>{ selectNode(node); e.cancelBubble = true; });
      // node.on('dragmove', ()=>{ if (ui.snap.checked) snapToGrid(node); });
      // node.on('transformend', ()=>{ if (ui.snap.checked) snapToGrid(node); });
      node.on('transformend', (e) => {
        removePropertyPanel();
        createPropertyPanel(node.attrs);
      });

    }

    function snapToGrid(node){
      const gx = Math.round(node.x()/GRID_SIZE)*GRID_SIZE;
      const gy = Math.round(node.y()/GRID_SIZE)*GRID_SIZE;
      node.position({x: gx, y: gy});
      layer.batchDraw();
    }


    // Create Properties functions
    function createTransformSection(container , properties = DEFAULT_PROPERTIES['transform']){
      const section = document.createElement('div');
      section.style = 'margin-bottom: 16px;';
      const heading = document.createElement('h3');
      heading.classList.add('text-14', 'poppins-medium', 'prop-heading');
      heading.textContent = 'Transform';
      section.appendChild(heading);

      // Create input fields for transform properties
      const createInput = (label, id) => {
        const labelElement = document.createElement('label');
        const inputElement = document.createElement('input');
        labelElement.classList.add('prop-label');
        inputElement.classList.add('prop-input');
        inputElement.id = id;
        inputElement.type = 'number';
        inputElement.name=label;
        inputElement.value = properties?.[label] ? parseFloat(properties?.[label]).toFixed(0) : DEFAULT_PROPERTIES['transform'][label];

        inputElement.addEventListener('change', (e) => {
          updateNodeStyle(tr.nodes()[0], e.target.name, e.target.value);
        });
        labelElement.appendChild(document.createTextNode(label));
        labelElement.appendChild(inputElement);
        section.appendChild(labelElement);
      };
      
      for(let key in  DEFAULT_PROPERTIES['transform']){
        createInput(key, `prop-${key}`);
      }

      container.appendChild(section);
    }

    // Create Properties Panels
    function createPropertyPanel(attrs){
      const stage = document.getElementById("stage-wrap");
      const propContainer = document.createElement("div");
      propContainer.id = "properties-drawer";
      const heading = document.createElement('h2');
      heading.classList.add("poppins-medium", "text-12");
      heading.textContent = 'Properties';
      propContainer.appendChild(heading);
      createTransformSection(propContainer, attrs);

      stage.appendChild(propContainer);
    }

    function removePropertyPanel(){
      const propContainer = document.getElementById("properties-drawer");
      if (propContainer) {
        propContainer.remove();
      }
    }

    // --- Add shapes ---
    document.getElementById('add-rect').onclick = ()=>{
      const rect = new Konva.Rect({ x: 80, y: 80, width: 160, height: 100, cornerRadius: 0, ...commonShapeProps() });
      layer.add(rect); rect.type='rect'; attachNodeEvents(rect); selectNode(rect);
    };

    document.getElementById('add-circle').onclick = ()=>{
      const circle = new Konva.Circle({ x: 280, y: 160, radius: 60, ...commonShapeProps() });
      layer.add(circle); circle.type='circle'; attachNodeEvents(circle); selectNode(circle);
    };

    document.getElementById('add-star').onclick = ()=>{
      const star = new Konva.Star({ x: 420, y: 160, numPoints: 5, innerRadius: 30, outerRadius: 60, ...commonShapeProps() });
      layer.add(star); star.type='star'; attachNodeEvents(star); selectNode(star);
    };

    document.getElementById('add-arrow').onclick = ()=>{
      const arrow = new Konva.Arrow({ points:[520,120,640,180], pointerLength: 12, pointerWidth: 12, tension: 0, lineCap:'round', lineJoin:'round', ...commonShapeProps() });
      layer.add(arrow); arrow.type='arrow'; attachNodeEvents(arrow); selectNode(arrow);
    };

    document.getElementById('add-text').onclick = ()=>{
      const text = new Konva.Text({ x: 120, y: 260, text: 'Double-click to edit', fontSize: 22, fontFamily: 'Inter, system-ui, sans-serif', ...commonShapeProps() });
      text.on('dblclick dbltap', () => { enableTextEdit(text); });
      layer.add(text); text.type='text'; attachNodeEvents(text); selectNode(text);
    };

    function enableTextEdit(textNode){
      isEditingText = true;
      const textPosition = textNode.absolutePosition();
      const stageBox = stage.container().getBoundingClientRect();
      const area = document.createElement('textarea');
      document.body.appendChild(area);
      area.value = textNode.text();
      area.style.position = 'absolute';
      area.style.top = stageBox.top + textPosition.y + 'px';
      area.style.left = stageBox.left + textPosition.x + 'px';
      area.style.width = textNode.width() + 'px';
      area.style.border = '1px solid #3b82f6';
      area.style.background = '#0b1220';
      area.style.color = '#e5e7eb';
      area.style.padding = '4px 6px';
      area.style.borderRadius = '6px';
      area.style.zIndex = 1000;
      area.focus();

      function finish(){
        textNode.text(area.value);
        area.remove();
        isEditingText = false;
        layer.draw();
      }
      area.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey) { e.preventDefault(); finish(); } });
      area.addEventListener('blur', finish);
    }

    // --- Stage events ---
    stage.on('click', (e)=>{ if (e.target === stage) selectNode(null); });

    stage.on('contextmenu', (e) => {
        e.evt.preventDefault(); 
        const stageBox = stage.container().getBoundingClientRect();
        contextMenuLocation = { x:stageBox.left + e.evt.clientX , y: stageBox.top + e.evt.clientY-30 };
        ui.contextMenu.style.top = contextMenuLocation.y + 'px';
        ui.contextMenu.style.left = contextMenuLocation.x + 'px';
        ui.contextMenu.style.display = 'block';
    });

    window.addEventListener('click', () => {
      ui.contextMenu.style.display = 'none';
    });

    // --- Toolbar actions ---
    document.getElementById('context-menu-delete-item').onclick = ()=>{
      const node = tr.nodes()[0];
      if(!node) return;
      if (node){ node.destroy(); selectNode(null); }
    };

    document.getElementById('context-menu-copy-item').onclick = ()=>{
      const node = tr.nodes()[0];
      if (!node) return;
      copiedNode = node.clone();
    };

    document.getElementById('context-menu-paste-item').onclick = ()=>{
      if (!copiedNode) return;
      const clone = copiedNode.clone({ x: contextMenuLocation.x - 20 , y: contextMenuLocation.y-20 });
      layer.add(clone); attachNodeEvents(clone); selectNode(clone);
    };

    // document.getElementById('bring-front').onclick = ()=>{
    //   const node = tr.nodes()[0];
    //   if (node){ node.moveToTop(); layer.draw(); }
    // };
    // document.getElementById('send-back').onclick = ()=>{
    //   const node = tr.nodes()[0];
    //   if (node){ node.moveToBottom(); layer.draw(); }
    // };

    // document.getElementById('export').onclick = ()=>{
    //   const url = stage.toDataURL({ pixelRatio: 2 });
    //   const a = document.createElement('a'); a.href = url; a.download = 'canvas-editor.png'; a.click();
    // };

    // document.getElementById('clear').onclick = ()=>{
    //   layer.find('.shape').forEach(n => n.destroy());
    //   selectNode(null); layer.draw();
    // };

    // style inputs apply to selected
    // ui.fill.addEventListener('input', ()=> applyStyle(tr.nodes()[0]));
    // ui.stroke.addEventListener('input', ()=> applyStyle(tr.nodes()[0]));
    // ui.strokeWidth.addEventListener('input', ()=> applyStyle(tr.nodes()[0]));
    // ui.cornerRadius.addEventListener('input', ()=> applyStyle(tr.nodes()[0]));

    // Image upload Change
    // ui.imageUpload.addEventListener('change', (e)=>{
    //   const file = e.target.files[0];
    //   if (!file) return;
    //   const reader = new FileReader();
    //   reader.onload = function(evt){
    //     const img = new Image();
    //     img.onload = function(){
    //       const konvaImage = new Konva.Image({ x: 100, y: 100, image: img, width: img.width, height: img.height, ...commonShapeProps() });
    //       konvaImage.cache();
    //       konvaImage.filters([Konva.Filters.Blur]);
    //       konvaImage.blurRadius(0); 
    //       layer.add(konvaImage); attachNodeEvents(konvaImage); selectNode(konvaImage);
    //       ui.imageUpload.value = '';
    //     };
    //     img.src = evt.target.result;
    //   };
    //   reader.readAsDataURL(file);
    // });

    // Add Blur Event for Image
    // ui.blurRadius.addEventListener('input', ()=> {
    //   const node = tr.nodes()[0];
    //   if (node && node.className === 'Image') {
    //     node.blurRadius(parseFloat(ui.blurRadius.value) || 0);
    //     layer.batchDraw();
    //   }
    // });


    // grid toggle
    // ui.grid.addEventListener('change', ()=>{ gridLayer.visible(ui.grid.checked); gridLayer.draw(); });

    // --- Keyboard shortcuts ---
    window.addEventListener('keydown', (e)=>{
      const node = tr.nodes()[0];
      if (e.key === 'Delete' || ( e.key === 'Backspace' && !isEditingText ) ) { if(node){ node.destroy(); selectNode(null);} }
      if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='d'){ e.preventDefault(); document.getElementById('duplicate').click(); }
      if (!node) return;
      const step = e.shiftKey ? 10 : 1;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
        e.preventDefault();
        const pos = node.position();
        if (e.key==='ArrowUp') pos.y -= step;
        if (e.key==='ArrowDown') pos.y += step;
        if (e.key==='ArrowLeft') pos.x -= step;
        if (e.key==='ArrowRight') pos.x += step;
        node.position(pos); layer.batchDraw();
      }
    });

    // --- Resize handling ---
    function fitStage(){
      const h = window.innerHeight - 70;
      stage.size({ width: window.innerWidth, height: h });
      drawGrid();
    }
    window.addEventListener('resize', fitStage);

    fitStage();
  </script>
</body>
</html>
